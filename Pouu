def backtest_all_tenors_swap_pca(
    model: dict,
    k: int = 3,
    roll: int = 60,
    ewma_span: int = 20,
    delta_size: float = 10000.0,
    z_entry: float = 1.5,
    z_exit: float = 0.5,
    hedge_cost_per_bp: float = 0.20,
):
    """
    Multi-tenor RV backtest using an EXISTING PCA model (no re-fit inside).

    Assumes `model` comes from run_curve_pca_on_returns(levels_df) and contains:
      - model["levels"]      : levels aligned to returns index
      - model["returns"]     : daily returns (diff) DataFrame
      - model["eigenvectors"]: PCA loadings (PCs x tenors)
      - model["mean"]        : mean of returns used for centering

    Trading rules:
      ENTRY on EWMA(z_raw):
        - if z_ewma <= -z_entry -> LONG  (+delta_size)
        - if z_ewma >= +z_entry -> SHORT (-delta_size)
      EXIT on raw:
        - if |z_raw| <= z_exit -> FLAT

    Costs:
      hedge_cost_per_bp * |Δpos|  (turnover in delta)

    Returns:
      perf_df        : per-tenor summary table
      pnl_curves_net : cumulative net PnL per tenor
      z_last_raw     : last raw z per tenor
      ret_hat        : reconstructed returns DataFrame (k PCs)
    """

    # -----------------------------
    # Pull from PCA model
    # -----------------------------
    levels: pd.DataFrame = model["levels"].copy()
    ret: pd.DataFrame = model["returns"].copy()
    EV: np.ndarray = model["eigenvectors"]
    mu: np.ndarray = model["mean"]

    # Basic checks
    if ret.empty or levels.empty:
        raise ValueError("Model contains empty levels/returns.")
    if not ret.index.equals(levels.index):
        # Align to common index safely
        common = ret.index.intersection(levels.index)
        ret = ret.loc[common]
        levels = levels.loc[common]
    if ret.shape[1] < 3:
        raise ValueError("Need at least 3 tenors to run multi-tenor backtest.")
    if len(ret) < max(roll + 20, 120):
        raise ValueError("Not enough observations for backtest given roll window.")

    # Ensure k is valid
    k = int(max(1, min(k, EV.shape[0])))

    # -----------------------------
    # Reconstruct returns with k PCs
    # -----------------------------
    EVk = EV[:k, :]
    Xc = ret.values - mu
    scores = Xc @ EVk.T
    Xhat = scores @ EVk + mu
    ret_hat = pd.DataFrame(Xhat, index=ret.index, columns=ret.columns)

    perf_rows = []
    pnl_curves_net = {}
    z_last_raw = {}

    # -----------------------------
    # Loop tenors
    # -----------------------------
    for tenor in ret.columns:
        # Residual on RETURNS space
        resid = ret[tenor] - ret_hat[tenor]

        # z-score (raw) on residual returns
        z_raw = (resid - resid.rolling(roll).mean()) / (resid.rolling(roll).std() + 1e-12)

        # entry signal: EWMA(z_raw)
        z_ewma = z_raw.ewm(span=int(ewma_span), adjust=False).mean()

        df = pd.DataFrame(
            {
                "y": levels[tenor],     # levels for pnl
                "z_raw": z_raw,
                "z_ewma": z_ewma,
            }
        ).dropna()

        if len(df) < max(roll + 20, 80):
            continue

        # Positions
        pos = 0.0
        last_entry = None
        pos_list = []

        for t in df.index:
            prev = pos
            zR = float(df.loc[t, "z_raw"])
            zE = float(df.loc[t, "z_ewma"])

            # EXIT on RAW
            if abs(zR) <= z_exit:
                pos = 0.0
            else:
                # ENTRY on EWMA
                if zE <= -z_entry:
                    pos = +delta_size
                elif zE >= +z_entry:
                    pos = -delta_size
                # else keep current pos

            if prev == 0.0 and pos != 0.0:
                last_entry = t

            pos_list.append(pos)

        df["pos"] = pos_list

        # PnL gross
        df["dy_bp"] = df["y"].diff()
        df["pnl_gross"] = df["pos"].shift(1).fillna(0.0) * df["dy_bp"]

        # Hedge cost on turnover in delta
        df["delta_change"] = df["pos"].diff().abs().fillna(df["pos"].abs())
        df["hedge_cost"] = hedge_cost_per_bp * df["delta_change"]

        # Net PnL
        df["pnl_net"] = df["pnl_gross"] - df["hedge_cost"]
        df["pnl_cum_net"] = df["pnl_net"].cumsum()

        # Metrics
        pnl_net = df["pnl_net"]
        sharpe_net = (
            float(pnl_net.mean() / (pnl_net.std() + 1e-12) * np.sqrt(252))
            if pnl_net.std() > 0
            else 0.0
        )
        maxdd_net = float((df["pnl_cum_net"] - df["pnl_cum_net"].cummax()).min())
        n_trades = int((df["pos"].diff().fillna(df["pos"]) != 0).sum())

        hedge_cost_cum = float(df["hedge_cost"].sum())
        last_pos = float(df["pos"].iloc[-1])
        last_z_raw = float(df["z_raw"].iloc[-1])
        z_last_raw[tenor] = last_z_raw

        close_t1 = float(df["y"].iloc[-2]) if len(df) >= 2 else np.nan
        close_t = float(df["y"].iloc[-1]) if len(df) >= 1 else np.nan
        delta_cum = float(df["pos"].abs().sum())
        daily_pnl = (close_t - close_t1) * delta_cum if np.isfinite(close_t1) and np.isfinite(close_t) else np.nan

        perf_rows.append(
            {
                "Tenor": tenor,
                "FinalPnL_net": float(df["pnl_cum_net"].iloc[-1]),
                "Sharpe_net": sharpe_net,
                "MaxDD_net": maxdd_net,
                "#Trades": n_trades,
                "HedgeCostCum": hedge_cost_cum,
                "LastZ_raw": last_z_raw,
                "Last entry date": last_entry.date() if last_entry is not None else None,
                "Current position (Δ)": last_pos,
                "Cumulative Δ traded": delta_cum,
                "Close t-1 (bp)": close_t1,
                "Close t (bp)": close_t,
                "DailyPnL (Δ_cum * Δclose)": float(daily_pnl) if daily_pnl is not None else np.nan,
            }
        )

        pnl_curves_net[tenor] = df["pnl_cum_net"]

    if not perf_rows:
        raise ValueError("No tenor could be backtested (too many NaNs / too short after filtering).")

    perf_df = pd.DataFrame(perf_rows).set_index("Tenor").sort_values("Sharpe_net", ascending=False)
    pnl_curves_net = pd.DataFrame(pnl_curves_net).dropna(how="all")

    return perf_df, pnl_curves_net, pd.Series(z_last_raw), ret_hat
